// PostgreSQL schema for production deployment (Render)
// Copy this to schema.prisma when deploying to Render

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// SQLite doesn't support enums, but PostgreSQL does
// For PostgreSQL, we can use enums, but keeping as String for compatibility

model Role {
  id        String   @id @default(cuid())
  name      String   @unique
  tasks     Task[]
  briefings BriefingLog[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Task {
  id          String   @id @default(cuid())
  roleId      String
  role        Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  title       String
  description String?
  priority    String // LOW, MEDIUM, HIGH, CRITICAL
  status      String // TODO, IN_PROGRESS, BLOCKED, DONE
  dueDate     DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model BriefingLog {
  id              String   @id @default(cuid())
  roleId          String
  role            Role     @relation(fields: [roleId], references: [id], onDelete: Cascade)
  generatedAt     DateTime @default(now())
  top3            String   // JSON string array
  alerts          String   // JSON string array
  blockers        String   // JSON string array
  dueOverdue      String   // JSON string array
  rawInputSummary String?
}

model User {
  id           String    @id @default(cuid())
  username     String    @unique
  passwordHash String
  role         String    @default("USER") // ADMIN or USER
  isActive     Boolean   @default(true)
  reputation   Int       @default(0)
  createdAt    DateTime  @default(now())
  sessions     Session[]
  posts        Post[]
  answers      Answer[]
  votes        Vote[]
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Post {
  id              String      @id @default(cuid())
  authorId        String
  author          User        @relation(fields: [authorId], references: [id], onDelete: Cascade)
  title           String
  content         String
  category        String // ONBOARDING, EQUIPMENT, PROCESS, QUALITY, LOGISTICS, SAFETY, GENERAL
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  isPinned        Boolean     @default(false)
  isLocked        Boolean     @default(false)
  acceptedAnswerId String?     @unique
  acceptedAnswer  Answer?     @relation("AcceptedAnswer", fields: [acceptedAnswerId], references: [id])
  answers         Answer[]
  votes           Vote[]
}

model Answer {
  id        String   @id @default(cuid())
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  authorId  String
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)
  content   String
  createdAt DateTime  @default(now())
  isDeleted Boolean   @default(false)
  acceptedPost Post?  @relation("AcceptedAnswer")
}

model Vote {
  id     String @id @default(cuid())
  postId String
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  value  Int    // +1 or -1
  @@unique([postId, userId])
}

